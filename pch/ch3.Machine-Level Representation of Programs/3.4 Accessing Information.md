footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

## 3.4 Accessing Information
x86-64 CPU는 64-bit 값을 저장하는 **general-purpose register** 16개를 포함하고 있습니다. 이 레지스터들은 포인터 뿐만아니라 integer data를 저장하는데 사용됩니다. 

[그림]()

레지스터 모든 이름은 `%r`로 시작합니다. 그렇지 않은 경우는 인스트럭션 set이 역사적으로 진화한것에서 기인하는데, 여러가지 서로다른 naming convention을 따르고 있습니다. Original 8086은 8개의 16-bit 레지스터들을 가지고 있었습니다. `%ax`부터 `%bp`가 이 레지스터들입니다. 이들은 특정한 목적을 가지고 있는데 이에 따라 이름지어졌습니다. IA32로 확장되면서, 이 레지스터들은 32-bit 레지스터들로 확장되었고, `%eax`부터 `%ebp`로 이름지어 졌습니다. x86-64로 확장되면서는, 원래 존재했던 8개의 레지스터들은 64-bit로 커졌으며, 이름은 `%rax` 부터 `%rbp`로 이름지어졌습니다. 이에 더해, 8개의 새로운 레지스터가 추가되었습니다. 그리고 그들은 naming convention에 따라서 `%r8`에서 `%r15`로 이름지어졌습니다.</br>

위 그림에 안쪽으로 겹쳐진 박스에서 처럼, 인스트럭션들은 16개의 레지스터 안에서의 low-order 바이트 크기의 데이터를 동작시킬 수 있습니다. Byte-level에서는 최소한의 바이트에 접근할 수 있고, 16-bit 계산은 2bytes, 32-bit 계산은 4bytes, 64-bit 계산은 전체 레지스터에 접근할 수 있게됩니다.</br>

이후 섹션들에서, 우리는 1, 2, 4, 8 바이트 값을 복사하고 생성하는 여러가지 인스트럭션을 확인할 예정입니다. 이 인스트럭션들이 레지스터를 목적지로써 가지고 있으면, 8byte보다 더적은 값을 생성하는 인스트럭션의 레지스터에 남아있는 값이 어떻게 되는지 두 가지 convention을 확인할 수 있습니다. 1, 2바이트의 경우에는 남아있는 바이트들을 변화시키지 않습니다. 4바이트의 경우에는 위 4 바이트를 0으로 설정합니다. 후자의 경우 IA32에서 x86-64로 넘어오면서 생긴 convention입니다.</br>

그림 맨 오른쪽의 annotation에서 확인할 수 있듯이, 다른 레지스터들은 프로그램안에서 서로 다른 역할을 수행합니다. 이 들중 가장 유니크한 것은 stack pointer(`%rsp`)인데, 런타임 스택안에서 끝 위치를 나타내는데 사용됩니다. 몇몇 인스트럭션들은 이 레지스터를 읽고 쓰는데 특정되어있습니다. 다른 15개의 레지스터들은 사용에 있어서 다소 유연합니다. 적은 숫자의 인스트럭션들만 이 레지스터들에 대한 사용이 특정되어있습니다. 더 중요한 것은, 기준 프로그래밍 convention들이 레지스터가 어떻게 스택을 관리하고, 함수 인자를 넘기고, 함수로 부터 값을 반환하고, 지역 및 임시 변수들을 저장하는지 결정합니다. 우리는 이 convention들을 3.7장에서 다룹니다.</br>

### 3.4.1 Operand Specifiers
대부분 인스트럭션들은 하나 또는 더 많은 `operand`를 가지고 있습니다. operand는 실행에 활용되는 source value와 결과를 저장하는 destination location을 나타냅니다. x86-64는 여러가지 형태의 operand를 지원합니다.

[그림]()

Source Value들은 레지스터나 메모리에서 읽어오거나 상수로 주어집니다. 결과들은 메모리나 레지스터에 저장됩니다. 따라서, operand 경우의 수는 세가지 경우로 구분됩니다. 첫번째, `immediate` 는 상수를 위한 것입니다. ATT 어셈블리 코드 형태에서, 이들은 `$` 다음에 interger가 오는 형식을 띕니다 (ex. `$-577` `$0x1F`). 다른 인스트럭션들은 immediate값이 다른 범위를 가질 수 있게 합니다. 그 말은 즉, 어셈블러가 자동으로 해당 값을 가장 콤팩트하게 인코딩한 값을 줍니다. 두번째, `register`는 레지스터에 들어있는 값을 나타냅니다. 이 값은 16개(레지스터 갯수)의 1, 2, 4, 8바이트 값을 가집니다. 위 그림을 보면, 우리는 `ra`가 register a를 가리키게끔 사용하고 있고 이것의 값은 R[ra] 레퍼런스로 참조합니다.</br>

세번째 operand는 `memory` 레퍼런스입니다. 우리는 `effective address`라 불리는 계산 된 주소에 따라 특정 메모리에 접근할 수 있습니다. 우리는 메모리를 큰 바이트 배열로 보기 때문에, 우리는 Mb[addr]이라는 notation을 통해 주소 addr부터 시작해서 byte b만큼 값을 참조한다고 나타냅니다. 이를 단순화 하기 위해, 우리는 보통 subcript b를 제거합니다.</br>

그림에서 보시는 바와 같이, 여러 형태의 메모리 참조를 가능하게 하는 여러 형태의 `addressing model`이 있습니다. 가장 일반 적인 형태는 표 가장 밑에 보이는 *Imm(rb, ri, s)* 형태입니다. 이런 참조는 4가지로 구성되어 있습니다. Immediate offset인 Imm, base 레지스터인 rb, index 레지스터인 ri, 그리고 scale factor인 s(s는 반드시 1, 2, 4, 8중 하나입니다.). base, index 모두 만드시 64-bit 레지스터여야합니다. 가장 효과적인 주소 계산법은 Imm + R[rb] + R[ri] * s입니다. 이 전형적인 형태는 배열 요소를 참조할 때도 확인 할 수 있습니다. 다른 형태는 이 요소들이 생략된 형태입니다. 나중에 확인하겠지만, 가장 복잡한 addressing mode는 구조체 요소와 배열을 참조하는데 유용합니다.</br>