footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

## 3.2 Programming Encodings

C언어로 p1.c, p2.c 2개의 파일을 만들었다고 가정해 봅시다. 우리는 이 코드들을 컴파일 할 수 있습니다.

```bash
linux> gcc -0g -o p p1.c p2.c
```

`gcc` 명령어는 gcc C 컴파일러를 뜻합니다. 이 컴파일러는 리눅스 default 컴파일러이기에 앞으로 간단히 `cc`로 부르겠습니다. 명령어 `-Og`는 컴파일러가 기계어를 만들때 최적화 정도를 나타내는 옵션입니다. 더 높은 레벨의 최적화는 기계어와 원 소스 코드간의 관계를 더 이해하기 어렵게됩니다. 우리는 `-0g` 최적화를 사용하고 레벨을 높임에따라 어떻게 되는지 살펴보도록 하겠습니다. 실제 예시에서, 더 높은 레벨의 최적화 `-O1 -O2`는 프로그램의 퍼포먼스 시각에서 보았을 때 더 좋은 결과를 만들어냅니다.</br>

`gcc` 명령어는 소스코드를 실행가능한 기계어로 변환시키는 단계를 거칩니다. 첫째, C언어 전처리기는 소스코드를 #include로 특정짓는 파일과 #define으로 특정지어지는 매크로까지 확장시킵니다. 해당 파일과 매크로를 포함시킨다고 생각하면 됩니다. 두번째, 컴파일러가 `p1.s`, `p2.s` 라는 이름을 가진 어셈블리 코드 파일을 생성합니다. 그 다음, 어셈블러가 어셈블리코드를 binary object-code로 구성된 p1.o p2.o로 변환합니다.Object 코드는 기계어의 한 형태입니다.(모든 instruction에 해당하는 binary 값을 가지고 있습니다. 하지만 아직 전역변수의 주소는 포함하고 있지 않습니다.) 마지막으로, 링커가 두 object-file과 라이브러리 함수를 실행하고 있는 코드를 합쳐서 최종적으로 실행가능한 파일인 `p`를 생성합니다. 실행가능한 코드는 기계어의 또 다른 형태입니다.(정확하게 CPU에 의해 실행될 수 있는 형태입니다.) 이러한 기계어의 서로 다른 형태와 링킹 과정 사이의 관계는 7장에서 살펴보도록 하겠습니다. </br>

### 3.2.1 Machine-Level Code

컴퓨터 시스템은 서로다른 형태의 추상화를 활용함으로써, 실제 실행의 상세한 부분을 감춥니다. 두가지 측면이 machine-level 프로그래밍에서 중요합니다. 첫번째, 기계어 프로그램의 동작과 형태는 `instruction set architecture`(ISA)에 정의 되어 있습니다. 여기서 프로세서의 상태, 인스트럭션의 형태, 그리고 각각의 인스트럭션이 가져올 영향등을 정의하고 있습니다. x86-64를 포함해, 대부분 ISA는 각각의 인스트럭션이 연속적으로 실행되는 것처럼(하나의 인스트럭션이 끝나고 그다음 인스트럭션이 실행되는) 프로그램의 동작을 설명하고 있습니다. 프로세서는 굉장히 정교해 여러개의 인스트럭션을 concurrent하게 실행하는데, 사실 프로세서는 연속적인 인스트럭션 실행을 ISA에 의해 보장받고 있습니다. 두번째, machine-level 프로그램에서 사용되는 메모리 주소는 가상메모리(virtual address)입니다. 가상메모리는 연속된 큰 바이트 배열인 메모리 모델을 제공합니다. 가상메모리 시스템의 실제 동작은 여러 운영체제 소프트웨어와 여러가지 하드웨어 메모리의 결합을 동반합니다. 이는 구장에서 살펴보도록 하겠습니다.</br>