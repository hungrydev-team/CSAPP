footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

## 3.2 Programming Encodings

C언어로 p1.c, p2.c 2개의 파일을 만들었다고 가정해 봅시다. 우리는 이 코드들을 컴파일 할 수 있습니다.

```bash
linux> gcc -0g -o p p1.c p2.c
```

`gcc` 명령어는 gcc C 컴파일러를 뜻합니다. 이 컴파일러는 리눅스 default 컴파일러이기에 앞으로 간단히 `cc`로 부르겠습니다. 명령어 `-Og`는 컴파일러가 기계어를 만들때 최적화 정도를 나타내는 옵션입니다. 더 높은 레벨의 최적화는 기계어와 원 소스 코드간의 관계를 더 이해하기 어렵게됩니다. 우리는 `-0g` 최적화를 사용하고 레벨을 높임에따라 어떻게 되는지 살펴보도록 하겠습니다. 실제 예시에서, 더 높은 레벨의 최적화 `-O1 -O2`는 프로그램의 퍼포먼스 시각에서 보았을 때 더 좋은 결과를 만들어냅니다.</br>

`gcc` 명령어는 소스코드를 실행가능한 기계어로 변환시키는 단계를 거칩니다. 첫째, C언어 전처리기는 소스코드를 #include로 특정짓는 파일과 #define으로 특정지어지는 매크로까지 확장시킵니다. 해당 파일과 매크로를 포함시킨다고 생각하면 됩니다. 두번째, 컴파일러가 `p1.s`, `p2.s` 라는 이름을 가진 어셈블리 코드 파일을 생성합니다. 그 다음, 어셈블러가 어셈블리코드를 binary object-code로 구성된 p1.o p2.o로 변환합니다.Object 코드는 기계어의 한 형태입니다.(모든 instruction에 해당하는 binary 값을 가지고 있습니다. 하지만 아직 전역변수의 주소는 포함하고 있지 않습니다.) 마지막으로, 링커가 두 object-file과 라이브러리 함수를 실행하고 있는 코드를 합쳐서 최종적으로 실행가능한 파일인 `p`를 생성합니다. 실행가능한 코드는 기계어의 또 다른 형태입니다.(정확하게 CPU에 의해 실행될 수 있는 형태입니다.) 이러한 기계어의 서로 다른 형태와 링킹 과정 사이의 관계는 7장에서 살펴보도록 하겠습니다. </br>

### 3.2.1 Machine-Level Code

컴퓨터 시스템은 서로다른 형태의 추상화를 활용함으로써, 실제 실행의 상세한 부분을 감춥니다. 두가지 측면이 machine-level 프로그래밍에서 중요합니다. 첫번째, 기계어 프로그램의 동작과 형태는 `instruction set architecture`(ISA)에 정의 되어 있습니다. 여기서 프로세서의 상태, 인스트럭션의 형태, 그리고 각각의 인스트럭션이 가져올 영향등을 정의하고 있습니다. x86-64를 포함해, 대부분 ISA는 각각의 인스트럭션이 연속적으로 실행되는 것처럼(하나의 인스트럭션이 끝나고 그다음 인스트럭션이 실행되는) 프로그램의 동작을 설명하고 있습니다. 프로세서는 굉장히 정교해 여러개의 인스트럭션을 concurrent하게 실행하는데, 사실 프로세서는 연속적인 인스트럭션 실행을 ISA에 의해 보장받고 있습니다. 두번째, machine-level 프로그램에서 사용되는 메모리 주소는 가상메모리(virtual address)입니다. 가상메모리는 연속된 큰 바이트 배열인 메모리 모델을 제공합니다. 가상메모리 시스템의 실제 동작은 여러 운영체제 소프트웨어와 여러가지 하드웨어 메모리의 결합을 동반합니다. 이는 9장에서 살펴보도록 하겠습니다.</br>

컴파일러는 컴파일 과정(C로 작성된 다소 추상적인 프로그램을 프로세서가 실행하는 기초 인스트럭션으로 바꾸는 과정)에서의 대부분의 일을 담당합니다. 어셈블리는 기계어에 매우 가까운 언어입니다. 어셈블리의 주요한 특징은 binary 형태의 기계어에 비해서 상대적으로 사람이 읽을 수 있는 텍스트 형태라는 점입니다. 어셈블리 코드와 C코드가 어떻게 연관되는지 이해하는 것은 컴퓨터가 프로그램을 어떻게 실행하는지를 이해하는데 있어 핵심 부분입니다. </br>

x86-64 기계어는 C코드와 다소 동 떨어져 있습니다. 프로세스 상태 등과 같은 정보는 C 프로그래머가 확인하기 힘듭니다.

- `program counter`(대개 PC라고 부르고 x86-63에서는 %rip라고 합니다.) 다음에 실행될 인스트럭션의 메모리 주소를 가리킵니다.
- 정수 `register file`은 64-bit를 저장하는 16개의 구역을 포함하고 있으며 각 구역은 자신만의 이름을 가지고 있습니다. 각각의 레지스터는 C포인터 처럼 주소값 또는 정수 값을 가지고 있습니다. 어떤 레지스터는 프로그램 상태의 중요한 부분을 담고 있지만 또 다른 레지스터 같은 경우는 임시 변수(argument나 지역 변수 함수가 반환한 값)를 저장하는데 사용됩니다.
- `condition code register`는 가장 최근에 실행된 산술 논리 인스트럭션에 대한 상태정보를 가지고 있습니다. 이들은 `if while`문 을 실행하는데 필요한 조건적인 변화를 실행하는데 사용됩니다.
- `vector register` set은 정수나 floating-point 값을 하나 또는 여러개 가질 수 있습니다.

C언어가 메모리상에서 allocate되고 선언될 수 있는 여러 데이터 타입에 관한 오브젝트 모델을 제공하는 반면에, 기계어는 메모리를 단순히 큰 바이트 주소 배열이라 해석합니다. 배열이나 구조체 같은 Aggregate 데이터 타입들은 기계어상에서 연속되는 바이트 모음으로 표현됩니다. 방향 구별이 없는 scalar data type에서도, 어셈블리 코드는 (signed, unsigned)와 (서로 다른 타입의 포인터) 그리고 심지어( 포인터와 정수)도 구분을 하지 않습니다. </br>

프로그램 메모리는 프로그램 실행에 필요한 기계어, 운영체제로부터 요청되는 정보, 프로시저 호출과 반환을 관리할 run-time stack, 유저에 의해 할당된 메모리를 포함합니다. 앞서 언급한것 처럼, 프로그램 메모리는 가상메모리를 통해 addressed됩니다. 예를 들어 x86-64 가상 메모리들은 64-bit word로 표현됩니다. 이 기계를 실행하면, 처음 16 bit들은 0으로 설정되고 따라서 주소는 2의 48승(64 terabyte)까지 표현할 수 있습니다. 보통 프로그램들은 오직 몇 메가바이트 또는 기가 바이트 정도에 까지만 접근할 것입니다. 운영체제가 이러한 가상메모리를 관리하고 있으며, 이러한 가상메모리를 실제 물리 메모리로 변환시켜줍니다.<br>

하나의 기계 인스트럭션은 오직 하나의 기초적인 동작만을 수행합니다. 예를 들어, 레지스터에 저장되어있는 두 숫자를 더하거나, 매모리와 레지스터 사이에서 데이터를 전달하거나, 또는 조건적으로 새로운 인스트럭션 주소로 옮겨가는 등의 동작을 수행합니다. 컴파일러는 수학적인 표현식, 반목문, 프로시저 호출 반환등과 같은 프로그램을 수행하기 위해서 반드시 연속되는 인스트럭션을 생성해야 합니다.</br>

#### Aside The ever-changing forms of generated code

이 장에서 우리는 특정한 gcc 버전과 특정한 명령어 옵션을 가지고 생성된 코드를 활용할 것입니다. 만약 여러분이 자기 컴퓨터로 코드를 컴파일하면, 다른 컴파일러 또는 다른 버전의 gcc를 사용했을 가능성이 있기에 코드가 다소 달라질 수 있습니다. gcc를 지원하는 오픈소스 커뮤니티는 마이크로프로세서 생산자가 제공하는 변화하는 코드 가이드 라인에 따라 더 효율적인 코드를 생성할 수 있도록 계속해서 코드 생성기를 업데이트하고 있습니다.</br>

우리의 목표는 우리의 장에서 공부하는 예시를 통해 어떻게 어셈블리 코드를 읽을지 그리고 어떻게 이를 더 높은 레벨의 언어 코드와 맵핑시키는지를 증명하는데 있습니다. 당신의 특정 컴퓨터가 생성해내는 코드 스타일과 이 기술들을 접목시킬 필요가 있습니다.</br>

### 3.2.2 Code Examples

아래와 같은 코드가 있다고 가정해 봅시다.

```c
long mult2(long, long);

void multstore(long x, long y, long *dest){
	long t = mult2(x, y);
	*dest = t;
}
```

컴파일러가 생성한 어셈블리 코드를 보기 위해, `-S` 옵션을 사용하도록 하겠습니다.

```bash
linux> gcc -Og -S mstore.c
```

이렇게 명령어를 치면 GCC가 컴파일러를 어셈블리 파일인 `mstore.s` 파일까지만 생성하게끔 합니다. (`-S`옵션이 없으면, GCC는 어셈블러가 object-code 파일까지 생성하게합니다.) 생성한 어셈블리 코드를 보면 아래와 같은 줄을 포함하는 것을 확인할 수 있습니다.

```assembly
pushq %rbx     
movq %rdx, %rbx  
call mult2@PLT  
movq %rax, (%rbx)  
popq %rbx    
ret  
```

각각의 줄은 하나의 기계 인스트럭션과 대응됩니다. 예를 들어 `pushq` 인스트럭션은 `%rbx`에 있는 데이터가 프로그램 스택에 들어가야함을 의미합니다. 지역변수 이름과 데이터 타입과 같은 모든 정보들은 사라진것을 볼 수 있습니다.</br>

`-c` 옵션을 사용하면 GCC는 컴파일과 어셈블을 동시에 수행하게 됩니다.

```
linux> gcc -Og -c mstore.c
```

이는 object-code 파일인 `mstore.o`를 생성합니다. 이 파일은 binary 형태이고 따라서 직접적으로 볼 수 없습니다. 1,368 바이트로 된 mstore.o 파일에는 이러한 연속되는 16 진법의 연속된 14 바이트가 있습니다.

```
53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3
```

이는 위에서 보여준 어셈블리 인스트럭션 하나하나와 대응되는 object code입니다. 여기서의 핵심은 기계에 의해서 실행되는 프로그램은 단순히 연속적인 인스트럭션을 인코딩한 단순한 바이트의 연속이라는 점입니다. 기계는 해당 인스트럭션을 만든 소스코드에 대한 아주 적은 정보만을 가지고 있습니다.</br>

머신 코드를 연구하기 위해서, `disassemblers`라는 매우 귀중한 프로그램이 있습니다. 이 프로그램들은 머신 코드로부터 어셈블리 코드와 유사한 포맷의 코드를 생성합니다. 리눅스에서는 `OBJDUMP` 가 `-d` flag와 함께 이러한 역할을 수행합니다.

```bash
linux> objdump -d mstore.o
```

결과는 아래와 같습니다.

```bash
mstore.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <multstore>:  
 0: 53                    push   %rbx  
 1: 48 89 d3              mov    %rdx,%rbx  
 4: e8 00 00 00 00        callq  9 <multstore+0x9>  
 9: 48 89 03              mov    %rax,(%rbx)  
 c: 5b                    pop    %rbx  
 d: c3                    retq
```

왼쪽에서 우리가 앞서 말했던 연속된 16진법의 14바이트 값들을 확인 할수 있습니다. 이 값들은 1부터 5바이트 값만큼 그룹화 되어있습니다. 각각의 그룹은 하나의 인스트럭션입니다.(오른쪽에 보여지는 어셈블리와 일치합니다.) 기계어와 이것의 disassemble한 표현에 있어 몇가지 알아둘만한 특징들이 있습니다.

- x86-64 인스트럭션은 길이 1 부터 15바이트까지 가질 수 있습니다. 인스트럭션 인코딩이 그렇게 되어 있습니다. 따라서 자주 사용되는 인스트럭션과 적은 operand를 사용하는 인스트럭션의 경우 적은 숫자의 바이트만 요구합니다.
- 따라서 이에 따른 유니크하게 기계어와 일치하는 바이트 decoding이 있습니다. 예를 들어, `push %rbx` 인스트럭션만 53 byte value로 시작할 수 있습니다.
- disassembler는 어셈블리 코드가 단순히 machine code file의 연속된 바이트에 기반해 있다고 생각합니다. disassembler는 그 프로그램의 어셈블리나 소스 코드 버전에 대한 접근을 요구하지 않습니다.
- disassembler는 인스트럭션에 대해 GCC가 생성하는 어셈블리코드와 다소 다른 naming convention을 사용하고 있습니다. 위 예시에서, 인스트럭션에서 많은 접미사 `q`가 생략된것을 볼 수 있습니다. 이 접미사들은 크기를 나타내는 것으로 대부분의 경우 생략될 수 있습니다. 반대로, disassembler가 `call`, `ret` 인스트럭션에 접미사 `q`를 붙인 것을 볼 수 있습니다. 이 접미사들 또한 생략가능합니다.

실행가능한 코드를 생성하는 것은 링커를 동작시키는 것이 필요합니다. 링커에게 object-code 파일들을 넘겨야합니다. 그리고 이 object-code 파일에는 `main` 함수가 반드시 있어야합니다. 아래와 같은 `main.c` 파일이 있다고 가정해 보겠습니다.

```c
#include <stdio.h>

void multstore(long, long, long *);

int main() {
	long d;
	multstore(2, 3, &d);
	printf("2 * 3 --> %ld\n", d);
	return 0;
}

long mult2(long a, long b) {
	long s = a * b;
	return s;
}
```

`main.c`와 `mstore.c`를 합쳐 실행가능한 `prog`를 만들어 보도록 하겠습니다.

```bash
linux> gcc -Og -o prog main.c mstore.c
```

prog 파일은 8,655 바이트까지 늘어났습니다. 왜냐하면 프로시저의 기계어 뿐만 아니라, 운영체제와 상호작용하며 프로그램을 시작하고 종료하는 코드까지 포함하고 있기 때문입니다. 위 prog 파일을 disassemble하겠습니다.

```bash
linux> objdump -d prog
```

해당 결과는 아래 코드를 포함해 많은 코드를 가지고 있습니다.

```bash
0000000000000741 <multstore>:  
 741: 53                    push   %rbx  
 742: 48 89 d3              mov    %rdx,%rbx  
 745: e8 ef ff ff ff        callq  739 <mult2>  
 74a: 48 89 03              mov    %rax,(%rbx)  
 74d: 5b                    pop    %rbx  
 74e: c3                    retq  
 74f: 90                    nop
```

이 코드는 mstore.c를 disassemble한 결과와 거의 동일합니다. 몇가지 다른점이 존재합니다. 하나는 옆에 나타난 주소 값이 달라졌습니다. 링커가 이 코드를 다른 주소로 옮겼기 때문입니다. 두번째는 링커가 `callq` 인스트럭션이 mult2 함수를 호출하는데 사용하는 주소를 채워넣었습니다. 링커가 하는 역할중 함수 호출을 함수들이 실제 실행되는 코드에서의 위치와 매칭하는 역할이 있습니다. 마지막으로 우리는 추가적인 1개의 줄을 확인할 수 있습니다 (line 8). 이 인스트럭션은 프로그램에 아무런 영향을 주지 않습니다. 왜냐하면 return 인스트럭션 다음에 동작하기 때문입니다. 이 인스트럭션은  코드를 16바이트까지 늘리기위해서 넣어진 것입니다. 그렇게 함으로써 다음 코드들의 위치를 더 좋게 함으로써 메모리 퍼포먼서를 높일 수 있기때문입니다.

