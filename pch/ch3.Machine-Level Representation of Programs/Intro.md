footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

## Intro

컴퓨터는 low-level 작업을 인코딩한 바이트의 연속적인 모음인 기계어를 실행하는 기계입니다. 컴파일러는 여러단계를 거쳐 기계어를 생성합니다. Gcc (C 컴파일러) 컴파일러는 어셈블리 형태의 기계어를 만들어냅니다. 어셈블리 코드는 프로그램 개별 인스트럭션을 텍스트 형태로 나타내는 코드입니다. Gcc는 어셈블러(assembler), 링커(linker)가 이 어셈블리를 통해 실행 가능한 기계어를 생성하게끔 합니다. 3장에서 우리는 이 기계어와 어셈블리 코드를 살펴볼 예정입니다. </br>

프로그래밍 언어들(c나 더 높은 단계인 자바 등등)은 우리 프로그램의 machine-level단계 실행으로부터 다소 떨어져 있습니다(추상화 되어있다는 것이 더 맞는 표현). 대조적으로, 어셈블리어를 통해 프로그램을 만들면, 프로그래머가 반드시 low-level 인스트럭션을 특정해주어야만 합니다. 대개는 high-level 언어가 제공하는 추상화가 개발하는데 더 생산적이고 신뢰할만 합니다. 컴파일러가 제공하는 타입 체킹은 많은 프로그램 오류를 사전에 발견하는데 도움이 되고 우리가 데이터를 일관된 방향으로 참조하고 가공하게끔 합니다. 최적화된 현대 컴파일러를 통해 우리는 숙련된 어셈블리 개발자보다 더 효율적으로 코드를 작성할 수 있습니다. 무엇보다도 high-level 언어로 작성된 프로그램은 다양한 기계에서 동작하지만, 어셈블리 코드는 보다 더 기계에 의존하는 특성을 가지고 있습니다. </br>

이런 모든 단점을 확인하고도 우리는 왜 머신 코드를 배워야 할까요? 비록 컴파일러가 어셈블리 코드를 생성하는 거의 모든 일을 도맡아 하지만, 어셈블리를 읽고 이해하는 것은 여전히 프로그래머에게 중요한 기술 중 하나입니다. 컴파일러에 적절한 argument 명령어를 주면, 컴파일러는 어셈블리 형태의 결과물을 보여주는 파일을 생성합니다. 이 코드를 읽음으로써, 우리는 컴파일러의 최적화 능력을 확인할 수 있고 더 나아가 해당 코드안에 들어있는 비 효율성을 분석할 수 있습니다. 5장에서 살펴보겠지만, 코드의 크리티컬한 퍼포먼스를 최대치로 끌어올리기를 원하는 개발자는 종종 다른 형태의 소스코드를 만드는데, 그 때마다 컴파일하고 생성된 어셈블리코드를 확인하면서 프로그램이 어떻게 효율적으로 동작할 수 있을지 알아냅니다. 게다가, 고 레벨 언어가 제공하는 추상화가 우리가 이해해야 하는 프로그램의 런타임 동작에 대한 정보를 숨기는 경우가 존재합니다. 예를 들어, (1	2장에서 확인할 내용입니다.) thread package를 활용하여 concurrent한 프로그램을 작성할 때, 서로 다른 스레드에 의해 프로그램 데이터가 어떻게 공유되거나 private하게 유지되는지 그리고 어떻게 공유된 데이터를 어디서 접근하는지를 이해하는 것이 중요합니다. 이러한 정보들은 기계어 레벨에서 확인할 수 있습니다. 다른 예시로는, 프로그램을 해킹하는 여러가지 방법이 있습니다. 이런 해킹 공격들은 시스템의 약점을 활용하여 프로그램이 정보를 덮어써서 궁국적으로 시스템에 대한 통제권을 가져옵니다. 이런 시스템 취약성을 이해하고 이를 어떻게 방어할 것인가는 기계어 수준에 대한 이해가 필요합니다. 기계어 수준에 대한 이해는 어셈블리 코드를 작성하는 것에서 이제 어셈블리 코드를 읽고 이해하는 수준으로 왔습니다. </br>

이 장에서, 우리는 특정 어셈블리 코드를 배우고 C 프로그램이 어떻게 이러한 형태의 기계 코드로 변환되는지 살펴볼 것입니다. 어셈블리 코드를 읽는 것은 어셈블리어를 작성하는 것과는 다른 기술이 요구됩니다. 우리는 컴파일러가 C언어를 기계 코드로 바꾸는 전형적인 방식을 이해해야 합니다. C언어로 작성된 계산과 비교하여, 최적화 컴파일러는 실행 순서를 재정렬하기도하고 필요하지 않는 계산을 제거하거나 느린 작업을 더 빠른 작업으로 교체하기도하고 심지어 recursive한 계산을 iterative하게 변경하기도 합니다. 소스코드와 어셈블리 코드 사이의 관계를 이해하는 것은 어려운 일입니다. 이것은 `reverse-engineering`의 한 형태입니다. 시스템을 공부하고 반대로 해봄으로써 system이 어떻게 만들어졌는지를 이해하고 이를 통해 프로세스를 이해하는 것입니다. 이 경우에 시스템은 어셈블리 코드로 구성된 프로그램입니다. 이렇게해서 우리는 reverse engineering을 다소 단순화할 수 있습니다. 왜냐하면 생성된 코드는 다소 전형적은 패턴을 따르고, 우리는 컴파일러가 몇가지 프로그램에 대한 코드를 만드는 것을 확인함으로써 이러한 패턴을 볼 수 있기 때문입니다. 이러한 과정에서, 많은 예시와 연습문제들이 여러 형태의 어셈블리 코드와 컴파일러를 보여줄 것 입니다. 이 작업은 앞으로 더 깊고 기초적인 개념들을 이해하는데 밑바탕이 될것입니다. 세부사항을 배우고 싶지 않아서 일반적인 원리를 이해하고 있다고 이야기하는 자들은 스스로를 속이고 있는 것입니다. 제공되는 예시와 연습문제들을 꼭 풀어보시고 해답과 여러분의 해결책을 꼭 비교해보시기 바랍니다.</br>

이 책은 x86-64에 기초합니다. x86-64 기계어는 오랜 기간동안 진화를 거듭해왔고 지금은 64bit 프로세서에 기반합니다. 우리는 Gcc와 리눅스에 기반한 특징들에 집중해서 공부하겠습니다.  C 언어 구조 `if`, `while`, `switch` 문법의 구조를 살펴보고 어떻게 실행되는지까지 공부합니다. 프로그램이 어떻게 런타임 스택을 유지하고 프로시저 사이에서 데이터와 제어권을 주고 받는지도 살펴봅니다. 그 다음, 배열, 구조체, union등의 데이터 구조가 machie level에서 어떻게 실행되는지를 살펴봅니다. 이러한 machie level 프로그래밍에 대한 이해를 바탕으로 우리는 범위를 벗어난 메모리 참조 그리고 buffer overflow 공격과 같은 시스템 취약점에 대해 알아볼 것입니다. 마지막으로 우리는 GDB 디버거를 활용해 machine-level 프로그램의 런타임 동작을 살펴보고 floating-point 데이터들의 동작과 실행이 machine-level에서 어떻게 되는지 공부하면서 이장을 마무리합니다.</br>

컴퓨터 산업은 최근 32-bit에서 64-bit 머신으로 넘어가고 있습니다. 32-bit 기계는 ram을 4기가바이트밖에 사용할 수 없습니다. 메모리 가격이 급격히 낮아지면서 우리의 컴퓨터에 대한 요구와 데이터크기가 증가했으며 이는 그 한계를 넘어선 요구를 하고 있습니다. 현재 64-bit 기계는 256 테러바이트의 메모리를 사용할 수 있고 16 엑사바이트까지 사용량을 늘릴 수 있습니다. 비로 그렇게 많은 메모리를 가진 기계가 와닿지 않지만, 4기가 바이트는 32-bit 기계가 가질 수 있는 최대치 였다는게 70, 80년대에 주효했습니다.</br>

우리늬 목표는 현대 운영체제를 타겟으로한 프로그래밍 언어와 c언어를 컴파일 할때 생성되는 machine-level 프로그램을 이해하는 것입니다. 따라서 x86-64의 보편적이지 않은 부분은 다루지 않을 것 입니다.