footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

## 3.3 Data Formats

Intel이 16-bit 아키텍쳐에서 32-bit 아키텍쳐로 진화했기에, 인텔은 16-bit type를 지칭하는 `word`를 사용합니다. 이에 기초해서, 그들은 32-bit를 `double-words`라고 하고 64-bit를 `quad words`라고 합니다. 아래 표는 원시 C type을 활용한 x86-64 표현을 보여줍니다.

| C declaration  | Intel data type | Assembly-code suffix | Size ( bytes) |
| -------------   | --------------- | ---------------------   | -----------    |
 | char                           |            Byte | b | 1 |
| short | Word | w | 2 |
| int | Double Word | l | 4 |
| long | Quad Word | q | 8 |
| char * | Quad Word | q | 8 |
| float | Single Precision | s | 4 |
| double | Double Precision | l | 8 |

`int`는 double words로 저장됩니다 (32 bits). 포인터는 8-byte의 quad words로 저장됩니다(64-bit 기계에서). x86-64에서, `long` 타입은 64bits로 동작합니다. 이번 장에서 우리 코드는 대부분 포인터와 `long` 데이터타입을 활용합니다. 따라서 우리는 quad words에서 동작할 것입니다. x86-64 인스트럭션 세트는 쿼드 워드 뿐만아닌  바이트, 워드, 더블워드까지 실행할 수 있습니다.</br>

Floating point숫자는 두개의 형태로 구성됩니다. Single-Precision(4 bytes, `float`), Double-Precision(8 bytes, `double`). x86과 연계된 마이크로프로세서들은 모든 floating-point 동작을 특별한 80-bit floating-point 방식으로 실행했습니다. 이 형태는 C에서 `long double`을 사용해 지정할 수 있습니다. 우리는 이 형태를 사용하지 않는 것을 추천합니다. 다른 기계와 호완이 되지 않고 일반적인 single, double precision을 가진 하드웨어에서 동작하지 않기 때문입니다.</br>

위 표가 보여주듯이, GCC에 의해 생성되는 대부분 어셈블리 인스트럭션은 크기를 가리키는 문자하나를 접미사로 가집니다. 예를 들어, 데이터를 옮기는 인스트럭션은 4가지 형태로 나누어집니다. `movb`, `movw`, `movl`, `movq`. 접미사 `l`은 double words로 사용됩니다. 왜냐하면 32-bit 크기가 `long words`로 연상되기 때문입니다. 어셈블리 코드는 `l`을 4 byte integer나 double-precision floating-point 숫자를 가리키는데 사용합니다. 헷갈릴 필요없습니다. 왜냐하면, floating-point code는 전혀다른 인스트럭션과 레지스터를 가지기 때문입니다.