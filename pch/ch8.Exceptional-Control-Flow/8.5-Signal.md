footer: Copyright © 2021 by HungryDev, All rights reserved
slidenumbers: true
autoscale: true
slide-transition: true
build-lists: true

#8.5 Signals

---

## Outline

- 지금까지 하드웨어와 소프트웨어가 협력해 제공하는 low-level exception mechanism
- 운영체제가 exceptional control flow형태중 하나인 context switch를 지원하기 위해 어떻게 exception을 활용하는지를 봐왔다.
- 여기서는 더 높은 레벨의 execeptional control flow를 볼것인데 그것은 바로 signal이다.

---

## Outline

- signal은 프로세스와 kernel이 다른 프로세스에 끼어드는것을 가능하게 해줍니다.
- 프로세스에 시스템상에서 어떤 event가 발생했음을 알리는 메시지입니다.

--- 

## 8.5.1 Signal Terminology

### 시그널이 특정 프로세스에 전달되는 과정은 크게 2가지 단계로 나뉘어집니다.

---

## 8.5.1 Signal Terminology

### Sending a signal

- 커널은 목적지 프로세스의 context의 상태를 변경함으로써 해당 프로세스에 시그널을 전송합니다.
- 시그널은 크게 2가지 이유중 한가지로 전달됩니다.

---

## 8.5.1 Signal Terminology

1. 커널이 시스템의 이벤트(0으로 나누기 또는 자식 프로세스의 종료)를 감지한 경우
2. 어떤 프로세스가 kill 함수를 통해 커널이 특정 프로세스에게 시그널을 보내게끔 명시적으로 요청한경우

cf) 프로세스는 자기 자신에게 시그널을 보낼 수 있습니다.

---

## 8.5.1 Signal Terminology

### Receving a signal

- Destinateion 프로세스는 커널에 의해 시그널을 전달에 어떤 반응을 하게끔 강제되어지는 떄에 시그널을 받습니다.
- Destination 프로세스는 해당 시그널을 무시하거나, 종료되거나, 해당 시그널을 signal handler로는 user-level 함수를 통해서 잡을수도 있습니다.

---

## 8.5.1 Signal Terminology


![inline](https://user-images.githubusercontent.com/34790763/111495401-ac3b5580-8782-11eb-991a-6449ec18117a.jpg)

---

## 8.5.1 Signal Terminology

### Pending Signal

- 보내졌으나 받아들여지지 않은 시그널을  pending 시그널이라합니다.
- 어떤 순간에서든, 특정 타입의 pending signal은 최대 한개밖에 있을 수 없습니다.
- 예를 들어 어떤 프로세스가 k 타입의 pending 시그널을 가지고 있고 다른 연속된 k 타입의 시그널이 프로세스에 보내지면 해당 시그널은 버려집니다.

---

## 8.5.1 Signal Terminology

### Pending Signal

- 프로세스는 선택적으로 특정 시그널의 수용을 막을 수 있습니다.
- 시그널이 블락되면 이것은 전달될수 있으나 야기된 pending 시그널은 해당 프로세스가 그 시그널을 언블락할 때까지 받아들여지지않습니다.

---

## 8.5.1 Signal Terminology

### Pending Signal

- 하나의 pending 시그널은 최대 한번만 받아들여집니다.
- 각각 프로세스마다 커널은 pending 시그널 set을 pending bit vector에 저장합니다.
- 블락된 시그널 set은 blocked bit vector에 저장합니다.
- 커널은 k 타입의 시그널이 전달될때마다 pending에 k bit를 할당하고 k 타입의 시그널이 받아들여지면 pending bit k를 꺠끗하게 지웁니다.

---

## 8.5.2 Sending Signals

Unix 시스템은 프로세스에 시그널을 보내는데 여러가지 메카니즘을 제공하는데 이는 process group이라는 개념에 의존하고 있습니다.

---

## 8.5.2 Sending Signals

### Process Groups

- 모든 프로세스는 정확히 단 하나의 프로세스 그룹에 속해 있습니다.
- 프로세스 그룹은 process group ID라는 양의 정수에 의해 구별됩니다.
- `getpgrp` 함수는 현재 프로세스의 프로세스 그룹 id를 반환합니다.

```c
#include <unistd.h>

pid_t getpgrp(void);
```

---

## 8.5.2 Sending Signals

### Process Groups

- 기본적으로 자식 프로세스는 부모 프로세스와 동일한 프로세스 그룹에 속하게 됩니다.
- `setpgid` 함수를 통해 프로세스는 자기 자신을 포함한 다른 프로세스의 프로세스 그룹을 변경할 수 있습니다.

```c
#include <unitstd.h>

int setpgid(pid_t pid, pid_t pgid);
```

---

## 8.5.2 Sending Signals

### Process Groups

- `setpgid` 함수는 pid 프로세스의 프로세스 그룹을 pgid로 변경합니다.
- pid가 0이면 현재 프로세스의 pid가 사용됩니다.
- pgid가 0이면 pid 프로세스의 pid가 프로세스 그룹 id로 사용됩니다. (예를 들어 프로세스 15213에서 setpgid(0, 0)을 하면 프로세스 그룹 id가 15213인 그룹이 만들어지고 프로세스 15213을 해당 그룹에 포함시킵니다.)

---

## 8.5.2 Sending Signals

### Sending Signals with the /bin/kill program

- /bin/kill 프로그램은 arbitary signal을 다른 프로세스에게 보낼 수 있습니다.
- 예를 들어, 

```bash
linux> /bin/kill -9 15213
```

은 프로세스 15213에게 시그널 9(SIGKILL)을 보냅니다.

---

## 8.5.2 Sending Signals

### Sending Signals with the /bin/kill program

- pid를 음수가 음수인 경우에는 프로세스 그룹 id가 pid인 모든 프로세스에게 해당 시그널을 보냅니다.

```bash
linux> /bin/kill -9 -15213
```

프로세스 그룹 id가 15213인 모든 프로세스에게 SIGKILL 시그널을 보내는 명령어 입니다.

- 몇몇 Unix 쉘들은 자기만의 kill 명령어를 가지고 있어 완전한 경로인 `/bin/kill`을 사용했습니다.

---

## 8.5.2 Sending Signals

### Sending Signals from the Keyboard

- Unix 쉘은 하나의 command line을 통해 생성된 프로세스를 나타나는데 `job`이라는 추상화를 사용합니다.

```bash
linux> ls | sort
```

- 위 명령어는 Unix pipe에 의해 연결된 두개의 프로세스로 구성된 foreground job을 생성합니다.(하나는 `ls` 프로세스, 다른 하나는 `sort` 프로세스 )

---

## 8.5.2 Sending Signals

### Sending Signals from the Keyboard

- 쉘은 각각 job마다 다른 프로세스 그룹을 생성합니다.
- 일반적으로, 프로세스 그룹 id는 해당 job의 부모프로세스중 하나의 프로세스로부터 가져와집니다.

---

## 8.5.2 Sending Signals

### Sending Signals from the Keyboard

Figure 8.28 그림
![Figure8.28]()

---

## 8.5.2 Sending Signals

### Sending Signals from the Keyboard

- Ctrl + C 키는 커널이 foreground process group에 있는 모든 프로세스에게 SIGINT 시그널을 보내게끔합니다.(디폴트는 foreground job을 종료시킵니다.)
- Ctrl + Z 키는 커널이 foreground process group에 있는 모든 프로세스에게 SIGSTP 시그널을 보내게끔 합니다.(디폴트는 foreground job을 중지시킵니다.)

---

## 8.5.2 Sending Signals

### Sending Signals with the kill function

- 프로세스는 `kill` 함수를 호출함으로써 자신을 포함한 다른 프로세스에게 시그널을 전달할 수 있습니다.

```c
#include <sys/type.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

---

## 8.5.2 Sending Signals

### Sending Signals with the kill function

- pid가 0보다 크면, pid 프로세스에게 `kill` 함수가 signal 숫자 sig를 보냅니다.
- pid가 0이면, `kill` 함수는 호출한 프로세스의 프로세스 그룹에 속해있는 모든 프로세스에게 signal 숫자 sig를 보냅니다.(자기 자신 포함)
- pid가 음수면, 절대값 pid인 프로세스 그룹의 모든 프로세스에게 시그널 sig를 보냅니다.

---

## 8.5.2 Sending Signals

### Figure 8.29

---

---

## 8.5.2 Sending Signals

### Sending Signals with the alarm Function

- 프로세스는 `alarm` 함수를 호출함으로써 자기 자신에게 SIGALRM 시그널을 보낼 수 있습니다.

```c
#include <unistd.h>

unsigned int alarm(unsigned int secs);
```

---

## 8.5.2 Sending Signals

### Sending Signals with the alarm Function

- `alarm` 함수는 커널이 SIGALRM 시그널을 호출한 프로세스에게 secs 초 안에 보내게끔 합니다.
- 만약 secs가 0이면, 새로운 알람이 스케줄되지 않습니다.
- 어떤 이벤트건 간에, `alarm` 함수 호출은 모든 pending alarm을 취소하고 다른 pending alarm이 전송될때까지 남은 시간을 초단위로 반환합니다. 또는 pending alarm이 없으면 0을 반환합니다.

---

## 8.5.3 Receiving Signals

- 커널이 process p를 커널모드에서 유저모드로 바꿀때 (시스템콜로부터  돌아올때, 콘텍스트 스위칭이 끝났을때 등등) 커널이 프로세스 p에 해당하는 블락되지않은 pending 시그널들을 체크합니다.
- 만약 set이 비어있으면 커널을 프로세스 p의 다음 인스트럭션에 제어권을 넘깁니다.
- 하지만 set이 비어 있지 않으면 커널은 k 시그널을 set에서 선택합니다. (대개 가장 작은 k 시그널)